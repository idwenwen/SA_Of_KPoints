# JAVASCRIPT

## 简介
  ECMAScript第一个标准版本是在1997年诞生的。
  2009年推出ES5标准版本
  2015年推行出现有的第六版本，之后逐年推出小版本。会加入相关的新特性。

## 概念与实践

### 变量与类型

#### 类型

  - 1. undefined
    - 定义：当前数值表示未定义，无任何形式的参数。
    - 特性：
      - global . undefined 就是undefined的存放点，只读。
      
      - JS 会自动地为声明当时没有定义的变量设置为undefined，类似与||undefined
      
      - typeof undefined === 'undefined'
      
        > <b>p.s. 如果说上下文中可以判定数据类型，我们应该尽量少用。
        依据上下文判定当前变量是否存在的形式会更为的合理。</b>

      - void 0 计算出来的数值便是undefined

        > <b>void：由于下一条undefined特性可知并不在某一作用域之中的undefined可能会被修改，void 0 一定返回当前全局的undefined变量。</b>
      
      - undefined并不是字面量(字面量：固定符号)，但是undefined在 JS 之中只是一种类型，并不是一个确定的保留字。也就是说undefined实际上是一个全局变量，而且是可以被修改的变量，我们可以在局部环境之中修改。只是我们一般最好不要也不会去修改。

- 2. null

  - 定义：表示的是空对象的意义，没有只想任何值的表示量。
  - 特性：
    - 不是全局变量，是JS的字面量。
    - typeof null === 'object'，这是一个遗留问题，JS之中的数值是有一个表示类型的标签和实际数值表示的，对象类型标签是0。由于空代表的是空指针大对数的平台的下面值为0x00，所以null的类型标签是0，typeof null也因此返回'object'。后有过提案，但是考虑到之后的影响，所以放弃了。

- 3. Boolean

  - 定义：布尔类型，具有true和false的两种类型。
  - 特性：
    - !!双非操作，转换相关数值为对应的布尔值内容。
    - Boolean是类型转换函数，也是对象的构造方法。所以我们在做类型转换的额时候是可以考虑使用的。Boolean对象之中只含有基本的原始值内容，以及基础方法。
    - 具体的数值之间的类型转换请看数值转换篇。

- 4. Number

  - 定义：数字类型，定义之中是不限定当前是整形还是浮点型。其实现的方式是64为双精度浮点数据（IEEE754）计算标准类型。（具体可见IEEE754说明这篇文章）
  - 特性：
    - 由于是64位用来表示数据的，所以将会有一个最大最小的的范围。Number之中提供MAX_VALUE以及MIN_VALUE两个可查询的数据。表示正数方向可表示的最大最小，如果前面加上负号表示的就是我们可以接受的负数最大与最小了。
    - 于此同时，其提供了INFINITY这样的标识符，表示的是超出可表示范围的数据内容。
    - +/-0实际上都是0，两者数值相同，符号的区分主要是为了确定当前数据的趋近方向的不同。
    - NaN表示非数字类型，其本身亦不于自己相等，当前标识在全局环境之中以及Number之中都有。所以我们可以意识到，NaN并不是一个字面量，所以我们作用域之中时可以进行赋值的。
    - Epsilon表示的是当前计数方式下的，可以实现的最小值是多少，这也是一个Number之中的常量内容。
    - MAX_SAFE_INTEGER / MIN_SAFE_INTEGER：表示的是可以表示的安全的整形数值的范围。
    - Number是一个构造函数同时也是一个转换函数。对于基础的几个标识符与字面量，需要着重对说一下，undefined转换之后是NaN，而不是0。
    - polyFill方法可见当前目录下的NumberExtension内容。

- 5. String

  - 定义：字符串类型数据，用于表示文本内容。
  - 特性:
    - 字符串类型可以理解位类数组内容，每一个字符作为一个数据项，整体长度作为字符串的长度。
    - 字符串创建之后是不可变的，炒作字符串的内容实际上是创建一个新的字符串。
    - JSON.stringify()将当前内容转换成JSON字符串。
    - es6之中加强了对unicode的支持力度。
    - 模板字符串的引入方便我们构建结构相似但是部分细节内容不相同的字符串内容。
    - 字符串的大小比较，实际上是逐字符比较的，判定当前的字符在编码方式之中的先后顺序。
    - String本身是一个构造方法，同时也是一个类型转换函数。
    - polyFill方法以及方法解析，可见StringExtension内容。（同路径下。）

- 6. Symbol

  - 定义：符号类型，用于表示唯一标识符。

  - 特性：

    - Symbol表示是唯一性，通过Symbol方法可以进行构建。返回的将会是唯一标识，同一个环境下面的相同的传参，的出来内容也是不相同的。

    - Symbol并不是传统意义上的构造函数，所以不可以使用new方法。

    - Symbol.for(key)方法，可以在全局范围内搜索是否已经有相关的标识。有则返回，无则创建并返回。

    - Symbol.keyFor(sym)方法，全局内容之中通过给定的标识符查询相关的key值。

    - 上面两个方法都是在全局范围内设定的标识符内容，但是通过Symbol创建的内容是不会放在Symbol的全局作用域之中的。

    - JS之中实际上已经有一些内容通过Symbol表示了，并设置到了我们的基础内容之中，例如遍历，match等方法。我们可以在创建对象的时候通过特性的标识符来重写当前对象的特定方法。

      > P.S. 内置方法之中，实际上ES5之前就设置了一些没有暴露给开发者的Symbol，此条特性就是覆盖原有方法，提供了新的逻辑。

#### 变量：

**问**：什么是变量？ 

**答**：变量就是存储了一定信息的可调用量，其中可能存储有字面量，以及指针。再理论化一些，指的便是栈之中的某一块存储区域。



**问**：如何理解字面量与指针？

**答**：字面量：是一种直观的数据内容，表示可以直接理解的数据，例如1，‘a’等等。

​		指针：是一种指向计算机存储区域的定位符。



**问**：为什么会有这种不同的存储方式？

**答**：程序运行的过程，每一个作用域实际上都会分配一小块存储空间，用于存储局部变量。但是对象由于牵扯的内容较多(包含变量与方法)，并不适合存储再较小的运行用的栈区域之中，所以会再存储空间中专门分配一块大的区域构建对象的存储关系。同时栈中也需要对象的内容方便调用，就会将堆中的存储位置的地址放入栈存储区域。所以一个变量之中可能会出现，可以直接表示，无需放入堆中存储的字面量，同时也会有需要放在堆中存储的对象的指针。

> 具体的堆与栈的区别可见运行原理一文。



**问**：数据内容底层存储形式是怎样的？

**答**：数据内容分为类型与原始数据，数据类型一般存储在二进制的低位。所以我们的数据本身可以判定类型，这也就是typeof的判定方式。但是由于object的细化类型是之后的程序之中衍生出来的，并没有在原始的数据类型之中有相关的判别，所以typeof并不能具体的判定是那一种详细的对象类型，统一都是object类型。



**问**：instanceof是如何判定某一个对象类型数据是属于哪一个类的呢？

**答**：首先需要理解原型链，个人理解原型链是一系列的细化分类的过程。

- 每一个事物都可以看成一个对象去理解，对象有相关特性（属性与方法），相同特性的对象视为同一类别，通过类别构造方法生产实例对象，每一个实例对象都有类别之中说明的属性，与方法，但是属性可能不相同。JS 之中的Object实际上是一个构造方法，所有的对象的构造方法。而Object.prototype则是可以理解为所有对象的父级，它只是表示对象的概念以及基础的对象的方法。

- 当我们构造一个我们特有的对象的时候，通过声明式的方式来创建的话，实际上其会调用Object方法作为构造函数，所以我们可以理解为Object.prototype是声明式创建的对象的父对象。我们可以在chrome之中打印出\__proto__这个变量，其展示的内容是Object.prototype。这个变量实际上是一种默认形式，来体现父子对象关系的。而在这个父对象之中可以看到constructor方法，它对应的就是Object这个构造方法。constructor就反馈了当前对象的构造方法。

- 我们可以设置function的prototype属性。实际上就是在改变当前函数构造出来的对象的父对象。这里比较推荐的方法是修改prototype内容，而不是直接覆盖掉原有的prototype属性，因为直接覆盖会修改掉当前原型链之中的指向。不难发现，修改的prototype后创建新对象，打印出来的\__proto__属性之中会有一个constructor属性自动指向构造方法，而覆盖了的prototype对象则生成的对象里面则没有constructor变量了。
- 由上面四点我们可以得知，实际上对象最终总是会关联到原始对象的，就像一条链一样环环相扣。这就是原型链。
- 还有一个我们需要注意的事情就是，由于JS遵循的是事物都是对象，所以Function实际上也是一个对象，不过是一类比较特殊的对象，我们打印Function的prototype属性，实际上就Object.\__proto__的内容，所以我们可以认为Object这个对象构造方法对象实际上是Function创建的。有一种说法，浏览器先创建出初始对象，一句初始对象创建了Function方法对象，再通过Function创建了基础对象的构造器方法Object。所以我们可以绘制下面这样一副关联关系图。

![原型链](F:\前端\review\basic\icon\原型链.png)

上面理解了原型链之后，在需要了解的是instanceof方法的原理了。



instanceof会按照原型链的向下查找，并右右侧运算数据的prototype属性进行比对。如果判定相同，实际上就可以确定左运算内容是否是继承于运算符右侧类型。代码段如下：

***function instance_of (obj, classes) {***

​	***let origin = classes.prototype***

​	**let extension = obj.\__proto__**

​	***while (extension) {***

​		***if (extension === origin) {***

​			***return true***

​		***} else {***

​			**extension = extension.\__proto__**

​		***}***

​	***}***

​	***return false***

***}***



**问**：如何理解对象描述符？

**答**：对象描述符。主要是对对象之中的属性的特性说明。主要由两种形式的描述符，具体依据当前属性是普通属性还是设置器属性。其可设置内容有。

- 普通属性：
  - configurable：boolean，当前属性是否可设置。false，表示当前的属性不可有任何描述上的修改(主要针对之后的两个设置属性)
  - enumable: boolean，当前属性是否可遍历。在for...in等iteration之中是否可获取。false表示当前属性不可遍历。configurable属性为false的话，enumable可以修改，但是只能修改为false。
  - writable: boolean，当前属性是否可写。false不可写，表示赋值操作将会无效化。当configurable属性为false的话，writable属性还是可以修改的，但是只能修改成为false
  - value: any，表示的是当前属性数值。
- 设置器属性：
  - configurable: 同上
  - enumable: 同上
  - getter：访问器属性方法，无任何参数，当访问当前属性的时候将会自动调用访问器方法，获取返回值。（一定要有返回哟）
  - setter：设置器属性方法，参数为新值，赋值设置器属性后会自动调用设置器方法。

当然普通的构造方法，会自动将属性设置为默认的配置属性，如果需要定制化当前属性的描述符需要我们调用，Object.defineProperty等属性设置方法，传递描述符对象。

属性描述符的运用：

- vue之中使用属性描述符的设置器访问器来进行数据的监控。
- 对于对象之中的特定属性可以进行可遍历的控制，来避免外部遍历访问当前属性。保有一部分的私有性。
- 对于对象之中的特定属性，或者固定存在属性，我们可以设置的configurable为false，避免当前属性被修改，或者删除。
- 对象之中的常量属性，通常是只读属性，这时我们应该考虑将此属性的configurable以及writable属性设置为false。



**问**：对象的反射机制的理解。

**答**：反射机制的概念可以如此理解，**运行状态中，可以获取对象之中详细信息（变量，方法）的功能**。js之中可以通过许多的方式获取对象之中的属性与方法，最为直接的便是Object.keys()，遍历当前的对象的可遍历的关键字内容。实际上也算是一种反射机制的体现。同时还有例如hasProperty等判定方法，判定当前对象之中的情况。

ES6之中更为规范的了反射机制的内容，统一归总到Reflect对象之中。MDN之中给出的解释是Reflect对象提供拦截javascript的操作方法，方法与proxy的handler之中的方法相同。



### 代码块与作用域

代码块：两个大括号中间的，都可以理解为代码块，其中可以包含一段完整的逻辑内容。

作用域：JS 之中我们可以把作用域分为全局作用域和局部作用域。

- 全局作用域：通常web端之中window对象可以理解为全局作用域，全局作用域意味着，在程序之中的所有代码段之中都可以获取的到的内容。
- 局部作用域：指的是函数的调用作用域，函数被调用的时候，实际上会有一个调用作用域，这个时候函数的代码块之中的逻辑将会自动的成为一个局部的作用域。可以定义只在当前代码块之中可用的变量。
- 块作用域：是局部作用域的一种，某一个代码块之中的定义的内容只可以在当前的代码块之中进行使用。这里的代码块可不单单是函数的代码块，而是所有一组大括号囊括的内容。



### 常见语句

- if ...( else if )... else ... : 判断语句，主要用结合布尔运算进行条件判定。
- switch (exp) ...case... : 同样是作为判定语句的一种，其更多的意味着匹配。exp是一个表达式会获取一个最终结果，case则是具体的结果内容，如果表达式的结果与case相同，则会运行当前case以及之后的对应的代码。
- while (exp) 循环语句，exp表达式返回一个布尔结果，如果是true则持续执行while语句之后的代码块。如果为false则跳出当前循环。
- for... of 遍历当前数组与类数组对象中的每一项内容。
- for... in 遍历对象之中的每一个可遍历项。获取相关键值。
- break与continue，break可以直接终止当前循环，默认种植当前层的循环，或者break之后带上loop的别称信息，则可以直接种终止相关的循环内容。continue这是终止当前次循环直接开始下一次的循环。
- typeof 语句用于判别内容的类型，其最终返回的结果大体只有undefined，number，string，boolean，symbol，object， function。

