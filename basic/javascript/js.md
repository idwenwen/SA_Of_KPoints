# JAVASCRIPT

## 简介
  ECMAScript第一个标准版本是在1997年诞生的。
  2009年推出ES5标准版本
  2015年推行出现有的第六版本，之后逐年推出小版本。会加入相关的新特性。

## 概念与实践

#### 类型

  - 1. undefined
    - 定义：当前数值表示未定义，无任何形式的参数。
    - 特性：
      - global . undefined 就是undefined的存放点，只读。
      
      - JS 会自动地为声明当时没有定义的变量设置为undefined，类似与||undefined
      
      - typeof undefined === 'undefined'
      
        > <b>p.s. 如果说上下文中可以判定数据类型，我们应该尽量少用。
        依据上下文判定当前变量是否存在的形式会更为的合理。</b>

      - void 0 计算出来的数值便是undefined

        > <b>void：由于下一条undefined特性可知并不在某一作用域之中的undefined可能会被修改，void 0 一定返回当前全局的undefined变量。</b>
      
      - undefined并不是字面量(字面量：固定符号)，但是undefined在 JS 之中只是一种类型，并不是一个确定的保留字。也就是说undefined实际上是一个全局变量，而且是可以被修改的变量，我们可以在局部环境之中修改。只是我们一般最好不要也不会去修改。

- 2. null

  - 定义：表示的是空对象的意义，没有只想任何值的表示量。
  - 特性：
    - 不是全局变量，是JS的字面量。
    - typeof null === 'object'，这是一个遗留问题，JS之中的数值是有一个表示类型的标签和实际数值表示的，对象类型标签是0。由于空代表的是空指针大对数的平台的下面值为0x00，所以null的类型标签是0，typeof null也因此返回'object'。后有过提案，但是考虑到之后的影响，所以放弃了。

- 3. Boolean

  - 定义：布尔类型，具有true和false的两种类型。
  - 特性：
    - !!双非操作，转换相关数值为对应的布尔值内容。
    - Boolean是类型转换函数，也是对象的构造方法。所以我们在做类型转换的额时候是可以考虑使用的。Boolean对象之中只含有基本的原始值内容，以及基础方法。
    - 具体的数值之间的类型转换请看数值转换篇。

- 4. Number

  - 定义：数字类型，定义之中是不限定当前是整形还是浮点型。其实现的方式是64为双精度浮点数据（IEEE754）计算标准类型。（具体可见IEEE754说明这篇文章）
  - 特性：
    - 由于是64位用来表示数据的，所以将会有一个最大最小的的范围。Number之中提供MAX_VALUE以及MIN_VALUE两个可查询的数据。表示正数方向可表示的最大最小，如果前面加上负号表示的就是我们可以接受的负数最大与最小了。
    - 于此同时，其提供了INFINITY这样的标识符，表示的是超出可表示范围的数据内容。
    - +/-0实际上都是0，两者数值相同，符号的区分主要是为了确定当前数据的趋近方向的不同。
    - NaN表示非数字类型，其本身亦不于自己相等，当前标识在全局环境之中以及Number之中都有。所以我们可以意识到，NaN并不是一个字面量，所以我们作用域之中时可以进行赋值的。
    - Epsilon表示的是当前计数方式下的，可以实现的最小值是多少，这也是一个Number之中的常量内容。
    - MAX_SAFE_INTEGER / MIN_SAFE_INTEGER：表示的是可以表示的安全的整形数值的范围。
    - Number是一个构造函数同时也是一个转换函数。对于基础的几个标识符与字面量，需要着重对说一下，undefined转换之后是NaN，而不是0。
    - polyFill方法可见当前目录下的NumberExtension内容。

- 5. String

  - 定义：字符串类型数据，用于表示文本内容。
  - 特性:
    - 字符串类型可以理解位类数组内容，每一个字符作为一个数据项，整体长度作为字符串的长度。
    - 字符串创建之后是不可变的，炒作字符串的内容实际上是创建一个新的字符串。
    - JSON.stringify()将当前内容转换成JSON字符串。
    - es6之中加强了对unicode的支持力度。
    - 模板字符串的引入方便我们构建结构相似但是部分细节内容不相同的字符串内容。
    - 字符串的大小比较，实际上是逐字符比较的，判定当前的字符在编码方式之中的先后顺序。
    - String本身是一个构造方法，同时也是一个类型转换函数。
    - polyFill方法以及方法解析，可见StringExtension内容。（同路径下。）

- 6. Symbol

  - 定义：符号类型，用于表示唯一标识符。

  - 特性：

    - Symbol表示是唯一性，通过Symbol方法可以进行构建。返回的将会是唯一标识，同一个环境下面的相同的传参，的出来内容也是不相同的。

    - Symbol并不是传统意义上的构造函数，所以不可以使用new方法。

    - Symbol.for(key)方法，可以在全局范围内搜索是否已经有相关的标识。有则返回，无则创建并返回。

    - Symbol.keyFor(sym)方法，全局内容之中通过给定的标识符查询相关的key值。

    - 上面两个方法都是在全局范围内设定的标识符内容，但是通过Symbol创建的内容是不会放在Symbol的全局作用域之中的。

    - JS之中实际上已经有一些内容通过Symbol表示了，并设置到了我们的基础内容之中，例如遍历，match等方法。我们可以在创建对象的时候通过特性的标识符来重写当前对象的特定方法。

      > P.S. 内置方法之中，实际上ES5之前就设置了一些没有暴露给开发者的Symbol，此条特性就是覆盖原有方法，提供了新的逻辑。

#### 变量：

**问**：什么是变量？ 

**答**：变量就是存储了一定信息的可调用量，其中可能存储有字面量，以及指针。再理论化一些，指的便是栈之中的某一块存储区域。



**问**：如何理解字面量与指针？

**答**：字面量：是一种直观的数据内容，表示可以直接理解的数据，例如1，‘a’等等。

​		指针：是一种指向计算机存储区域的定位符。



**问**：为什么会有这种不同的存储方式？

**答**：程序运行的过程，每一个作用域实际上都会分配一小块存储空间，用于存储局部变量。但是对象由于牵扯的内容较多(包含变量与方法)，并不适合存储再较小的运行用的栈区域之中，所以会再存储空间中专门分配一块大的区域构建对象的存储关系。同时栈中也需要对象的内容方便调用，就会将堆中的存储位置的地址放入栈存储区域。所以一个变量之中可能会出现，可以直接表示，无需放入堆中存储的字面量，同时也会有需要放在堆中存储的对象的指针。

> 具体的堆与栈的区别可见运行原理一文。



**问**：数据内容底层存储形式是怎样的？

**答**：数据内容分为类型与原始数据，数据类型一般存储在二进制的低位。所以我们的数据本身可以判定类型，这也就是typeof的判定方式。但是由于object的细化类型是之后的程序之中衍生出来的，并没有在原始的数据类型之中有相关的判别，所以typeof并不能具体的判定是那一种详细的对象类型，统一都是object类型。



#### 原型链

**问**：instanceof是如何判定某一个对象类型数据是属于哪一个类的呢？

**答**：首先需要理解原型链，个人理解原型链是一系列的细化分类的过程。

- 每一个事物都可以看成一个对象去理解，对象有相关特性（属性与方法），相同特性的对象视为同一类别，通过类别构造方法生产实例对象，每一个实例对象都有类别之中说明的属性，与方法，但是属性可能不相同。JS 之中的Object实际上是一个构造方法，所有的对象的构造方法。而Object.prototype则是可以理解为所有对象的父级，它只是表示对象的概念以及基础的对象的方法。

- 当我们构造一个我们特有的对象的时候，通过声明式的方式来创建的话，实际上其会调用Object方法作为构造函数，所以我们可以理解为Object.prototype是声明式创建的对象的父对象。我们可以在chrome之中打印出\__proto__这个变量，其展示的内容是Object.prototype。这个变量实际上是一种默认形式，来体现父子对象关系的。而在这个父对象之中可以看到constructor方法，它对应的就是Object这个构造方法。constructor就反馈了当前对象的构造方法。

- 我们可以设置function的prototype属性。实际上就是在改变当前函数构造出来的对象的父对象。这里比较推荐的方法是修改prototype内容，而不是直接覆盖掉原有的prototype属性，因为直接覆盖会修改掉当前原型链之中的指向。不难发现，修改的prototype后创建新对象，打印出来的\__proto__属性之中会有一个constructor属性自动指向构造方法，而覆盖了的prototype对象则生成的对象里面则没有constructor变量了。
- 由上面四点我们可以得知，实际上对象最终总是会关联到原始对象的，就像一条链一样环环相扣。这就是原型链。
- 还有一个我们需要注意的事情就是，由于JS遵循的是事物都是对象，所以Function实际上也是一个对象，不过是一类比较特殊的对象，我们打印Function的prototype属性，实际上就Object.\__proto__的内容，所以我们可以认为Object这个对象构造方法对象实际上是Function创建的。有一种说法，浏览器先创建出初始对象，一句初始对象创建了Function方法对象，再通过Function创建了基础对象的构造器方法Object。所以我们可以绘制下面这样一副关联关系图。

![原型链](..\icon\原型链.png)

上面理解了原型链之后，在需要了解的是instanceof方法的原理了。



instanceof会按照原型链的向下查找，并右右侧运算数据的prototype属性进行比对。如果判定相同，实际上就可以确定左运算内容是否是继承于运算符右侧类型。代码段如下：

```js
function instance_of (obj, classes) {

	let origin = classes.prototype

	let extension = obj.__proto__

	while (extension) {

		if (extension === origin) {

			return true

		} else {

			extension = extension.__proto__

		}

	}

	return false

}
```



#### 对象描述符

**问**：如何理解对象描述符？

**答**：对象描述符。主要是对对象之中的属性的特性说明。主要由两种形式的描述符，具体依据当前属性是普通属性还是设置器属性。其可设置内容有。

- 普通属性：
  - configurable：boolean，当前属性是否可设置。false，表示当前的属性不可有任何描述上的修改(主要针对之后的两个设置属性)
  - enumable: boolean，当前属性是否可遍历。在for...in等iteration之中是否可获取。false表示当前属性不可遍历。configurable属性为false的话，enumable可以修改，但是只能修改为false。
  - writable: boolean，当前属性是否可写。false不可写，表示赋值操作将会无效化。当configurable属性为false的话，writable属性还是可以修改的，但是只能修改成为false
  - value: any，表示的是当前属性数值。
- 设置器属性：
  - configurable: 同上
  - enumable: 同上
  - getter：访问器属性方法，无任何参数，当访问当前属性的时候将会自动调用访问器方法，获取返回值。（一定要有返回哟）
  - setter：设置器属性方法，参数为新值，赋值设置器属性后会自动调用设置器方法。

当然普通的构造方法，会自动将属性设置为默认的配置属性，如果需要定制化当前属性的描述符需要我们调用，Object.defineProperty等属性设置方法，传递描述符对象。

属性描述符的运用：

- vue之中使用属性描述符的设置器访问器来进行数据的监控。
- 对于对象之中的特定属性可以进行可遍历的控制，来避免外部遍历访问当前属性。保有一部分的私有性。
- 对于对象之中的特定属性，或者固定存在属性，我们可以设置的configurable为false，避免当前属性被修改，或者删除。
- 对象之中的常量属性，通常是只读属性，这时我们应该考虑将此属性的configurable以及writable属性设置为false。



#### 对象代理

**问**：对象的反射机制的理解。

**答**：反射机制的概念可以如此理解，**运行状态中，可以获取对象之中详细信息（变量，方法）的功能**。js之中可以通过许多的方式获取对象之中的属性与方法，最为直接的便是Object.keys()，遍历当前的对象的可遍历的关键字内容。实际上也算是一种反射机制的体现。同时还有例如hasProperty等判定方法，判定当前对象之中的情况。

ES6之中更为规范的了反射机制的内容，统一归总到Reflect对象之中。MDN之中给出的解释是Reflect对象提供拦截javascript的操作方法，方法与proxy的handler之中的方法相同。

当然可能是为了更为规范并符合逻辑的原因，所以Reflect之中的方法与原来的Object之中的相似方法名称，以及返回值会有一些差别。所以转变使用Reflect的时候一定要注意。



**问**：说说对Proxy的理解

**答**：Proxy对象创建的是一个对象的代理，从而实现基本操作的拦截和自定义。在使用的时候我们需要通过new来创建，所以我们可以理解为，当前的内容实际上是一个新的对象，而这个新的对象所做的事情是，控制待监听对象的相关的操作，并做一些自定义处理。这是JS之中对于代理模式的运用。VUE3 之中耶通过Proxy来进行内容的监听，这样监听可以保证数组类型的数据变化也会被监听到。

Proxy也支持多层代理，这样的话，我们完全可以借用AOP的思想，通过proxy来实现。将安全判定，一定的事务等内容防止在Proxy之中进行确定。配合TS之中的注解进行注入的形式，我们完全可以实现前端的基础AOP。



#### 代码块与作用域

代码块：两个大括号中间的，都可以理解为代码块，其中可以包含一段完整的逻辑内容。

作用域：JS 之中我们可以把作用域分为全局作用域和局部作用域。

- 全局作用域：通常web端之中window对象可以理解为全局作用域，全局作用域意味着，在程序之中的所有代码段之中都可以获取的到的内容。
- 局部作用域：指的是函数的调用作用域，函数被调用的时候，实际上会有一个调用作用域，这个时候函数的代码块之中的逻辑将会自动的成为一个局部的作用域。可以定义只在当前代码块之中可用的变量。
- 块作用域：是局部作用域的一种，某一个代码块之中的定义的内容只可以在当前的代码块之中进行使用。这里的代码块可不单单是函数的代码块，而是所有一组大括号囊括的内容。



#### 常见语句

- if ...( else if )... else ... : 判断语句，主要用结合布尔运算进行条件判定。
- switch (exp) ...case... : 同样是作为判定语句的一种，其更多的意味着匹配。exp是一个表达式会获取一个最终结果，case则是具体的结果内容，如果表达式的结果与case相同，则会运行当前case以及之后的对应的代码。
- while (exp) 循环语句，exp表达式返回一个布尔结果，如果是true则持续执行while语句之后的代码块。如果为false则跳出当前循环。
- for... of 遍历当前数组与类数组对象中的每一项内容。
- for... in 遍历对象之中的每一个可遍历项。获取相关键值。
- break与continue，break可以直接终止当前循环，默认种植当前层的循环，或者break之后带上loop的别称信息，则可以直接种终止相关的循环内容。continue这是终止当前次循环直接开始下一次的循环。
- typeof 语句用于判别内容的类型，其最终返回的结果大体只有undefined，number，string，boolean，symbol，object， function。



#### Promise

什么是Promise？JS中可以理解为一个占位符。代码运行到当前内容时候，有一定的数据内容需要我们异步才能获取，所以我需要给程序一个预定义的占位符，说明会给逻辑一个承诺，异步获取到数据之后会给与占位符。这样我们就可以将原本异步的形式与回调，语义化成为同步的形式。通过占位符代替当前没有获取但是需要的数据。

上述是对Promise的理解，也有同学将promise理解为一个承诺对象，承诺一个将来会给定的数值。也是相同的。

promise是如何使用的呢。看一段代码

```js
new.promise(function(resolve, reject) {

	if (err) reject(err)

	resolve(res)

})
```

这里我们可以看到，Promise对象之中传递的是一个方法，同时方法之中有resolve以及reject两个方法，这两个方法，一个是在完成的时候调用的，一个是在出现错误的时候调用的来拒绝当前的承诺。

由上面可知，promise实际上是会有**三种状态**的。

1. **pending**: 初始化状态，也就是我们常说的待定状态。
2. **fulfilled**: 表示承诺已经对象，也就是当调用了resolve方法之后设置的状态。
3. **rejected**：表示承诺已经拒绝了，意味着当前的操作失败了，也就是调用rejected之后的状态。



上面是生成了一个promise对象，那么Promise是如何将代码同步化的呢。

promise对象可以，调用如下方式，获取相关的信息，并进行promise之后的步骤。

1. **then** ( function resolve, function reject ): then方法表示承诺兑现之后，获取需要的信息，然后需要进行的后续步骤。function resolve表示的是resolve的后续操作，function reject表示的是调用reject的后续操作。可以获取promise对象之中reject方法传递的数据。并最后将返回数值作为Promise进行下一步操作。
2. **catch** ( function reject )：抓取当前reject抛出的错误信息。并返回一个结果给到promise链中的下一环。
3. **finally**（function final）：final方法获取的返回时resolve或者reject



由于我们可以看到调用方法实际上是返回一个新的promise，所以Promise之后的内容实际上是一个链式调用的形式，也符合它将异步转化称为同步的理念。

当然具体看调用形式，实际上promise本身还是以一种回调的形式来调用之后的内容，那么**为什么说它是符合安全异步的形式的呢**？这是因为，以往的异步形式，需要我们的传递回调方法，这样的话实际上回调方法的具体调用时间和次数都是由调用方说了算，这样的话实际上是及其不安全的，因为调用方有任何的修改，都会影响到回调函数触发。而使用promise的话就不会出现这个问题，回调函数的调用事件和机制掌握在触发方，而调用方只需要返回带有具体数值的promise就可以了，这样通过promise来达成一个双方可信赖的基础。

**为什么说promise可以解决回调地狱？**什么是回调地狱。启始我们程序之中往往回调的内容将不会是一层，可能由于一处是异步的情况，所以相关的逻辑需要多层回调，所以这个时候由于回调产生的逻辑变动以及耦合就很容易产生，这样便使得代码十分的凌乱，不易维护，从而会有回调地狱的问题出现。而promise则可以为我们处理回调地狱提供一种发放时。通过promise的形式，我们可以发现需要通过回调的逻辑可以放在原调用方之中通过then方法来自主的调用，这样回调之间的耦合可以解开，同时也提高了代码逻辑的内聚性。

promise对象也不仅仅只有上面的方法，同时也提供了许多其他的内容，例如我们在处理多个promise执行，并且需要在多个都执行完成的情况下才能执行后面的内容，单凭上面的方式是没有办法处理的，所以Promise也为我们提供了许多的静态方法。

1. Promise.all( arr[Promise] )：传递的是promise数组，当数组之中的所有promise都运行完成了之后才会调用之后的内容，并且外层promise的状态将会依据内层所有的promise的状态来确定，只有当内部所有的promise的都完成了才会外城promise才会变成fullfill状态。
2. Promise.race( arr[Promise] )：传递的是promise数组内容，但是与all不相同的是，当前方法传递的promise之中只要有一个pomise状态改变了话，外城promise就会有所改变。
3. Promise.allSettled( arr[Promise] )：当所有的内容都已经完成了，则外城promise会自动设置称为fullfill，不论子promise完成时候的状态。
4. Promise.any( any[Promise] )：表示的是只要传递的promise数组之中的任何一个promise状态转变成为fullfill则promise的状态是为fullfill。（逻辑类似于或）
5. Promise.resolve()：直接生成一个状态是fullfill的promise内容并返回。
6. Promise.reject()：直接生成一个状态是reject的promise内容并返回。
7. Promise.try()：有的时候需要使用promise但是不确定当前的方法是否需要同步的情况下，我们可以使用try方法，如果方法是同步的，则同步运行，如果方法是异步的，则异步运行，类似于async的效果。



我们应该如何**通过ployfill的形式添加对于promise的支持呢**？（TODO）



#### 生成器

generator也是JS提供的一种异步编程。它称作生成器方法。其关键字主要是*与yield。调用函数之后获取的是一个可遍历对象，其中的数据顺序是yield输出的数据顺序。那为什么说是一种异步编程的方法呢？因为在yield关键字处，当前程序将会自动pending。然后运行其他的程序内容，只有当我们调用next方法的时候，才会继续之前的地方执行。当然生成器函数也可以配合 for...of循环使用，这样会自动调用next方法来来获取生成器之中的数据。

当然js之中也有提供针对生成器方法的语法糖，async与await，async函数实际上是一个会自动调用的生成器函数，无需我们调用next函数了，同时其可以配合promise使用，因为awiat可以帮助我们拆解promise内容获取数据，同时返回的数据也会自动的组装成为一个promise。





