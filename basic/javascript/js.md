# JAVASCRIPT

## 简介

ECMAScript 第一个标准版本是在 1997 年诞生的。
2009 年推出 ES5 标准版本
2015 年推行出现有的第六版本，之后逐年推出小版本。会加入相关的新特性。

## 概念与实践

#### 类型

- 1. undefined

  - 定义：当前数值表示未定义，无任何形式的参数。
  - 特性：

    - global . undefined 就是 undefined 的存放点，只读。

    - JS 会自动地为声明当时没有定义的变量设置为 undefined，类似与||undefined

    - typeof undefined === 'undefined'

      > <b>p.s. 如果说上下文中可以判定数据类型，我们应该尽量少用。
      > 依据上下文判定当前变量是否存在的形式会更为的合理。</b>

    - void 0 计算出来的数值便是 undefined

      > <b>void：由于下一条 undefined 特性可知并不在某一作用域之中的 undefined 可能会被修改，void 0 一定返回当前全局的 undefined 变量。</b>

    - undefined 并不是字面量(字面量：固定符号)，但是 undefined 在 JS 之中只是一种类型，并不是一个确定的保留字。也就是说 undefined 实际上是一个全局变量，而且是可以被修改的变量，我们可以在局部环境之中修改。只是我们一般最好不要也不会去修改。

- 2. null

  - 定义：表示的是空对象的意义，没有只想任何值的表示量。
  - 特性：
    - 不是全局变量，是 JS 的字面量。
    - typeof null === 'object'，这是一个遗留问题，JS 之中的数值是有一个表示类型的标签和实际数值表示的，对象类型标签是 0。由于空代表的是空指针大对数的平台的下面值为 0x00，所以 null 的类型标签是 0，typeof null 也因此返回'object'。后有过提案，但是考虑到之后的影响，所以放弃了。

- 3. Boolean

  - 定义：布尔类型，具有 true 和 false 的两种类型。
  - 特性：
    - !!双非操作，转换相关数值为对应的布尔值内容。
    - Boolean 是类型转换函数，也是对象的构造方法。所以我们在做类型转换的额时候是可以考虑使用的。Boolean 对象之中只含有基本的原始值内容，以及基础方法。
    - 具体的数值之间的类型转换请看数值转换篇。

- 4. Number

  - 定义：数字类型，定义之中是不限定当前是整形还是浮点型。其实现的方式是 64 为双精度浮点数据（IEEE754）计算标准类型。（具体可见 IEEE754 说明这篇文章）
  - 特性：
    - 由于是 64 位用来表示数据的，所以将会有一个最大最小的的范围。Number 之中提供 MAX_VALUE 以及 MIN_VALUE 两个可查询的数据。表示正数方向可表示的最大最小，如果前面加上负号表示的就是我们可以接受的负数最大与最小了。
    - 于此同时，其提供了 INFINITY 这样的标识符，表示的是超出可表示范围的数据内容。
    - +/-0 实际上都是 0，两者数值相同，符号的区分主要是为了确定当前数据的趋近方向的不同。
    - NaN 表示非数字类型，其本身亦不于自己相等，当前标识在全局环境之中以及 Number 之中都有。所以我们可以意识到，NaN 并不是一个字面量，所以我们作用域之中时可以进行赋值的。
    - Epsilon 表示的是当前计数方式下的，可以实现的最小值是多少，这也是一个 Number 之中的常量内容。
    - MAX_SAFE_INTEGER / MIN_SAFE_INTEGER：表示的是可以表示的安全的整形数值的范围。
    - Number 是一个构造函数同时也是一个转换函数。对于基础的几个标识符与字面量，需要着重对说一下，undefined 转换之后是 NaN，而不是 0。
    - polyFill 方法可见当前目录下的 NumberExtension 内容。

- 5. String

  - 定义：字符串类型数据，用于表示文本内容。
  - 特性:
    - 字符串类型可以理解位类数组内容，每一个字符作为一个数据项，整体长度作为字符串的长度。
    - 字符串创建之后是不可变的，炒作字符串的内容实际上是创建一个新的字符串。
    - JSON.stringify()将当前内容转换成 JSON 字符串。
    - es6 之中加强了对 unicode 的支持力度。
    - 模板字符串的引入方便我们构建结构相似但是部分细节内容不相同的字符串内容。
    - 字符串的大小比较，实际上是逐字符比较的，判定当前的字符在编码方式之中的先后顺序。
    - String 本身是一个构造方法，同时也是一个类型转换函数。
    - polyFill 方法以及方法解析，可见 StringExtension 内容。（同路径下。）

- 6. Symbol

  - 定义：符号类型，用于表示唯一标识符。

  - 特性：

    - Symbol 表示是唯一性，通过 Symbol 方法可以进行构建。返回的将会是唯一标识，同一个环境下面的相同的传参，的出来内容也是不相同的。

    - Symbol 并不是传统意义上的构造函数，所以不可以使用 new 方法。

    - Symbol.for(key)方法，可以在全局范围内搜索是否已经有相关的标识。有则返回，无则创建并返回。

    - Symbol.keyFor(sym)方法，全局内容之中通过给定的标识符查询相关的 key 值。

    - 上面两个方法都是在全局范围内设定的标识符内容，但是通过 Symbol 创建的内容是不会放在 Symbol 的全局作用域之中的。

    - JS 之中实际上已经有一些内容通过 Symbol 表示了，并设置到了我们的基础内容之中，例如遍历，match 等方法。我们可以在创建对象的时候通过特性的标识符来重写当前对象的特定方法。

      > P.S. 内置方法之中，实际上 ES5 之前就设置了一些没有暴露给开发者的 Symbol，此条特性就是覆盖原有方法，提供了新的逻辑。

#### 变量：

**问**：什么是变量？

**答**：变量就是存储了一定信息的可调用量，其中可能存储有字面量，以及指针。再理论化一些，指的便是栈之中的某一块存储区域。

**问**：如何理解字面量与指针？

**答**：字面量：是一种直观的数据内容，表示可以直接理解的数据，例如 1，‘a’等等。

 指针：是一种指向计算机存储区域的定位符。

**问**：为什么会有这种不同的存储方式？

**答**：程序运行的过程，每一个作用域实际上都会分配一小块存储空间，用于存储局部变量。但是对象由于牵扯的内容较多(包含变量与方法)，并不适合存储再较小的运行用的栈区域之中，所以会再存储空间中专门分配一块大的区域构建对象的存储关系。同时栈中也需要对象的内容方便调用，就会将堆中的存储位置的地址放入栈存储区域。所以一个变量之中可能会出现，可以直接表示，无需放入堆中存储的字面量，同时也会有需要放在堆中存储的对象的指针。

> 具体的堆与栈的区别可见运行原理一文。

**问**：数据内容底层存储形式是怎样的？

**答**：数据内容分为类型与原始数据，数据类型一般存储在二进制的低位。所以我们的数据本身可以判定类型，这也就是 typeof 的判定方式。但是由于 object 的细化类型是之后的程序之中衍生出来的，并没有在原始的数据类型之中有相关的判别，所以 typeof 并不能具体的判定是那一种详细的对象类型，统一都是 object 类型。

#### 原型链

**问**：instanceof 是如何判定某一个对象类型数据是属于哪一个类的呢？

**答**：首先需要理解原型链，个人理解原型链是一系列的细化分类的过程。

- 每一个事物都可以看成一个对象去理解，对象有相关特性（属性与方法），相同特性的对象视为同一类别，通过类别构造方法生产实例对象，每一个实例对象都有类别之中说明的属性，与方法，但是属性可能不相同。JS 之中的 Object 实际上是一个构造方法，所有的对象的构造方法。而 Object.prototype 则是可以理解为所有对象的父级，它只是表示对象的概念以及基础的对象的方法。

- 当我们构造一个我们特有的对象的时候，通过声明式的方式来创建的话，实际上其会调用 Object 方法作为构造函数，所以我们可以理解为 Object.prototype 是声明式创建的对象的父对象。我们可以在 chrome 之中打印出\_\_proto\_\_这个变量，其展示的内容是 Object.prototype。这个变量实际上是一种默认形式，来体现父子对象关系的。而在这个父对象之中可以看到 constructor 方法，它对应的就是 Object 这个构造方法。constructor 就反馈了当前对象的构造方法。

- 我们可以设置 function 的 prototype 属性。实际上就是在改变当前函数构造出来的对象的父对象。这里比较推荐的方法是修改 prototype 内容，而不是直接覆盖掉原有的 prototype 属性，因为直接覆盖会修改掉当前原型链之中的指向。不难发现，修改的 prototype 后创建新对象，打印出来的\_\_proto\_\_属性之中会有一个 constructor 属性自动指向构造方法，而覆盖了的 prototype 对象则生成的对象里面则没有 constructor 变量了。
- 由上面四点我们可以得知，实际上对象最终总是会关联到原始对象的，就像一条链一样环环相扣。这就是原型链。
- 还有一个我们需要注意的事情就是，由于 JS 遵循的是事物都是对象，所以 Function 实际上也是一个对象，不过是一类比较特殊的对象，我们打印 Function 的 prototype 属性，实际上就 Object.\_\_proto\_\_的内容，所以我们可以认为 Object 这个对象构造方法对象实际上是 Function 创建的。有一种说法，浏览器先创建出初始对象，一句初始对象创建了 Function 方法对象，再通过 Function 创建了基础对象的构造器方法 Object。所以我们可以绘制下面这样一副关联关系图。

![原型链](..\icon\原型链.png)

上面理解了原型链之后，在需要了解的是 instanceof 方法的原理了。

instanceof 会按照原型链的向下查找，并右右侧运算数据的 prototype 属性进行比对。如果判定相同，实际上就可以确定左运算内容是否是继承于运算符右侧类型。代码段如下：

```js
function instance_of(obj, classes) {
  let origin = classes.prototype;

  let extension = obj.__proto__;

  while (extension) {
    if (extension === origin) {
      return true;
    } else {
      extension = extension.__proto__;
    }
  }

  return false;
}
```

#### 对象描述符

**问**：如何理解对象描述符？

**答**：对象描述符。主要是对对象之中的属性的特性说明。主要由两种形式的描述符，具体依据当前属性是普通属性还是设置器属性。其可设置内容有。

- 普通属性：
  - configurable：boolean，当前属性是否可设置。false，表示当前的属性不可有任何描述上的修改(主要针对之后的两个设置属性)
  - enumable: boolean，当前属性是否可遍历。在 for...in 等 iteration 之中是否可获取。false 表示当前属性不可遍历。configurable 属性为 false 的话，enumable 可以修改，但是只能修改为 false。
  - writable: boolean，当前属性是否可写。false 不可写，表示赋值操作将会无效化。当 configurable 属性为 false 的话，writable 属性还是可以修改的，但是只能修改成为 false
  - value: any，表示的是当前属性数值。
- 设置器属性：
  - configurable: 同上
  - enumable: 同上
  - getter：访问器属性方法，无任何参数，当访问当前属性的时候将会自动调用访问器方法，获取返回值。（一定要有返回哟）
  - setter：设置器属性方法，参数为新值，赋值设置器属性后会自动调用设置器方法。

当然普通的构造方法，会自动将属性设置为默认的配置属性，如果需要定制化当前属性的描述符需要我们调用，Object.defineProperty 等属性设置方法，传递描述符对象。

属性描述符的运用：

- vue 之中使用属性描述符的设置器访问器来进行数据的监控。
- 对于对象之中的特定属性可以进行可遍历的控制，来避免外部遍历访问当前属性。保有一部分的私有性。
- 对于对象之中的特定属性，或者固定存在属性，我们可以设置的 configurable 为 false，避免当前属性被修改，或者删除。
- 对象之中的常量属性，通常是只读属性，这时我们应该考虑将此属性的 configurable 以及 writable 属性设置为 false。

#### 对象代理

**问**：对象的反射机制的理解。

**答**：反射机制的概念可以如此理解，**运行状态中，可以获取对象之中详细信息（变量，方法）的功能**。js 之中可以通过许多的方式获取对象之中的属性与方法，最为直接的便是 Object.keys()，遍历当前的对象的可遍历的关键字内容。实际上也算是一种反射机制的体现。同时还有例如 hasProperty 等判定方法，判定当前对象之中的情况。

ES6 之中更为规范的了反射机制的内容，统一归总到 Reflect 对象之中。MDN 之中给出的解释是 Reflect 对象提供拦截 javascript 的操作方法，方法与 proxy 的 handler 之中的方法相同。

当然可能是为了更为规范并符合逻辑的原因，所以 Reflect 之中的方法与原来的 Object 之中的相似方法名称，以及返回值会有一些差别。所以转变使用 Reflect 的时候一定要注意。

**问**：说说对 Proxy 的理解

**答**：Proxy 对象创建的是一个对象的代理，从而实现基本操作的拦截和自定义。在使用的时候我们需要通过 new 来创建，所以我们可以理解为，当前的内容实际上是一个新的对象，而这个新的对象所做的事情是，控制待监听对象的相关的操作，并做一些自定义处理。这是 JS 之中对于代理模式的运用。VUE3 之中耶通过 Proxy 来进行内容的监听，这样监听可以保证数组类型的数据变化也会被监听到。

Proxy 也支持多层代理，这样的话，我们完全可以借用 AOP 的思想，通过 proxy 来实现。将安全判定，一定的事务等内容防止在 Proxy 之中进行确定。配合 TS 之中的注解进行注入的形式，我们完全可以实现前端的基础 AOP。

#### 代码块与作用域

代码块：两个大括号中间的，都可以理解为代码块，其中可以包含一段完整的逻辑内容。

作用域：JS 之中我们可以把作用域分为全局作用域和局部作用域。

- 全局作用域：通常 web 端之中 window 对象可以理解为全局作用域，全局作用域意味着，在程序之中的所有代码段之中都可以获取的到的内容。
- 局部作用域：指的是函数的调用作用域，函数被调用的时候，实际上会有一个调用作用域，这个时候函数的代码块之中的逻辑将会自动的成为一个局部的作用域。可以定义只在当前代码块之中可用的变量。
- 块作用域：是局部作用域的一种，某一个代码块之中的定义的内容只可以在当前的代码块之中进行使用。这里的代码块可不单单是函数的代码块，而是所有一组大括号囊括的内容。

#### 常见语句

- if ...( else if )... else ... : 判断语句，主要用结合布尔运算进行条件判定。
- switch (exp) ...case... : 同样是作为判定语句的一种，其更多的意味着匹配。exp 是一个表达式会获取一个最终结果，case 则是具体的结果内容，如果表达式的结果与 case 相同，则会运行当前 case 以及之后的对应的代码。
- while (exp) 循环语句，exp 表达式返回一个布尔结果，如果是 true 则持续执行 while 语句之后的代码块。如果为 false 则跳出当前循环。
- for... of 遍历当前数组与类数组对象中的每一项内容。
- for... in 遍历对象之中的每一个可遍历项。获取相关键值。
- break 与 continue，break 可以直接终止当前循环，默认种植当前层的循环，或者 break 之后带上 loop 的别称信息，则可以直接种终止相关的循环内容。continue 这是终止当前次循环直接开始下一次的循环。
- typeof 语句用于判别内容的类型，其最终返回的结果大体只有 undefined，number，string，boolean，symbol，object， function。

#### Promise

什么是 Promise？JS 中可以理解为一个占位符。代码运行到当前内容时候，有一定的数据内容需要我们异步才能获取，所以我需要给程序一个预定义的占位符，说明会给逻辑一个承诺，异步获取到数据之后会给与占位符。这样我们就可以将原本异步的形式与回调，语义化成为同步的形式。通过占位符代替当前没有获取但是需要的数据。

上述是对 Promise 的理解，也有同学将 promise 理解为一个承诺对象，承诺一个将来会给定的数值。也是相同的。

promise 是如何使用的呢。看一段代码

```js
new.promise(function (resolve, reject) {
  if (err) reject(err);

  resolve(res);
});
```

这里我们可以看到，Promise 对象之中传递的是一个方法，同时方法之中有 resolve 以及 reject 两个方法，这两个方法，一个是在完成的时候调用的，一个是在出现错误的时候调用的来拒绝当前的承诺。

由上面可知，promise 实际上是会有**三种状态**的。

1. **pending**: 初始化状态，也就是我们常说的待定状态。
2. **fulfilled**: 表示承诺已经对象，也就是当调用了 resolve 方法之后设置的状态。
3. **rejected**：表示承诺已经拒绝了，意味着当前的操作失败了，也就是调用 rejected 之后的状态。

上面是生成了一个 promise 对象，那么 Promise 是如何将代码同步化的呢。

promise 对象可以，调用如下方式，获取相关的信息，并进行 promise 之后的步骤。

1. **then** ( function resolve, function reject ): then 方法表示承诺兑现之后，获取需要的信息，然后需要进行的后续步骤。function resolve 表示的是 resolve 的后续操作，function reject 表示的是调用 reject 的后续操作。可以获取 promise 对象之中 reject 方法传递的数据。并最后将返回数值作为 Promise 进行下一步操作。
2. **catch** ( function reject )：抓取当前 reject 抛出的错误信息。并返回一个结果给到 promise 链中的下一环。
3. **finally**（function final）：final 方法获取的返回时 resolve 或者 reject

由于我们可以看到调用方法实际上是返回一个新的 promise，所以 Promise 之后的内容实际上是一个链式调用的形式，也符合它将异步转化称为同步的理念。

当然具体看调用形式，实际上 promise 本身还是以一种回调的形式来调用之后的内容，那么**为什么说它是符合安全异步的形式的呢**？这是因为，以往的异步形式，需要我们的传递回调方法，这样的话实际上回调方法的具体调用时间和次数都是由调用方说了算，这样的话实际上是及其不安全的，因为调用方有任何的修改，都会影响到回调函数触发。而使用 promise 的话就不会出现这个问题，回调函数的调用事件和机制掌握在触发方，而调用方只需要返回带有具体数值的 promise 就可以了，这样通过 promise 来达成一个双方可信赖的基础。

**为什么说 promise 可以解决回调地狱？**什么是回调地狱。启始我们程序之中往往回调的内容将不会是一层，可能由于一处是异步的情况，所以相关的逻辑需要多层回调，所以这个时候由于回调产生的逻辑变动以及耦合就很容易产生，这样便使得代码十分的凌乱，不易维护，从而会有回调地狱的问题出现。而 promise 则可以为我们处理回调地狱提供一种发放时。通过 promise 的形式，我们可以发现需要通过回调的逻辑可以放在原调用方之中通过 then 方法来自主的调用，这样回调之间的耦合可以解开，同时也提高了代码逻辑的内聚性。

promise 对象也不仅仅只有上面的方法，同时也提供了许多其他的内容，例如我们在处理多个 promise 执行，并且需要在多个都执行完成的情况下才能执行后面的内容，单凭上面的方式是没有办法处理的，所以 Promise 也为我们提供了许多的静态方法。

1. Promise.all( arr[Promise] )：传递的是 promise 数组，当数组之中的所有 promise 都运行完成了之后才会调用之后的内容，并且外层 promise 的状态将会依据内层所有的 promise 的状态来确定，只有当内部所有的 promise 的都完成了才会外城 promise 才会变成 fullfill 状态。
2. Promise.race( arr[Promise] )：传递的是 promise 数组内容，但是与 all 不相同的是，当前方法传递的 promise 之中只要有一个 pomise 状态改变了话，外城 promise 就会有所改变。
3. Promise.allSettled( arr[Promise] )：当所有的内容都已经完成了，则外城 promise 会自动设置称为 fullfill，不论子 promise 完成时候的状态。
4. Promise.any( any[Promise] )：表示的是只要传递的 promise 数组之中的任何一个 promise 状态转变成为 fullfill 则 promise 的状态是为 fullfill。（逻辑类似于或）
5. Promise.resolve()：直接生成一个状态是 fullfill 的 promise 内容并返回。
6. Promise.reject()：直接生成一个状态是 reject 的 promise 内容并返回。
7. Promise.try()：有的时候需要使用 promise 但是不确定当前的方法是否需要同步的情况下，我们可以使用 try 方法，如果方法是同步的，则同步运行，如果方法是异步的，则异步运行，类似于 async 的效果。

我们应该如何**通过 ployfill 的形式添加对于 promise 的支持呢**？（TODO）

#### 生成器

generator 也是 JS 提供的一种异步编程。它称作生成器方法。其关键字主要是\*与 yield。调用函数之后获取的是一个可遍历对象，其中的数据顺序是 yield 输出的数据顺序。那为什么说是一种异步编程的方法呢？因为在 yield 关键字处，当前程序将会自动 pending。然后运行其他的程序内容，只有当我们调用 next 方法的时候，才会继续之前的地方执行。当然生成器函数也可以配合 for...of 循环使用，这样会自动调用 next 方法来来获取生成器之中的数据。

当然 js 之中也有提供针对生成器方法的语法糖，async 与 await，async 函数实际上是一个会自动调用的生成器函数，无需我们调用 next 函数了，同时其可以配合 promise 使用，因为 awiat 可以帮助我们拆解 promise 内容获取数据，同时返回的数据也会自动的组装成为一个 promise。
